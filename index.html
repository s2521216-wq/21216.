<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테트리스 프로그램 (개발자: 전현주)</title>
    <style>
        /* 기본 스타일 */
        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0d1117; /* GitHub Dark Theme */
            color: #c9d1d9;
            padding: 20px;
            overflow-y: auto;
        }

        /* 메인 컨테이너 */
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            padding: 20px;
            background-color: #161b22;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 95%;
        }

        /* 정보 패널 (개발자 정보, 점수, 다음 블록) */
        .info-panel {
            display: flex;
            flex-direction: column;
            width: 150px;
            gap: 20px;
        }

        .header-info {
            background-color: #21262d;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        h1 {
            color: #58a6ff; /* Blue accent */
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .developer-info {
            font-size: 0.8em;
            color: #8b949e;
        }

        /* 스코어 & 다음 블록 영역 */
        .score-box, .next-box {
            background-color: #21262d;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .score-box p, .next-box p {
            margin: 5px 0;
            font-weight: bold;
        }
        
        #score {
            color: #f08047; /* Orange accent */
            font-size: 1.5em;
        }

        /* 다음 블록 캔버스 */
        #next-canvas {
            border: 1px solid #30363d;
            background-color: #0d1117;
            border-radius: 4px;
        }

        /* 게임 캔버스 */
        #game-canvas {
            border: 5px solid #58a6ff; /* Blue border */
            border-radius: 8px;
            background-color: #0d1117;
            box-shadow: 0 0 15px rgba(88, 166, 255, 0.5);
        }

        /* 게임 오버 메시지 */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            z-index: 10;
            text-align: center;
        }

        #message-overlay.active {
            display: flex;
        }

        #message-overlay h2 {
            color: #e66767; /* Red accent */
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #e66767;
        }
        
        #message-overlay p {
            font-size: 1.5em;
            margin-top: 0;
        }

        /* 버튼 스타일 */
        .controls-panel {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            background-color: #58a6ff;
            color: #0d1117;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 3px 0 #3a75c4;
        }

        button:hover {
            background-color: #79c0ff;
        }

        button:active {
            background-color: #3a75c4;
            transform: translateY(3px);
            box-shadow: none;
        }

        /* 모바일 터치 컨트롤 */
        .mobile-controls {
            display: none; /* 기본적으로 숨김 */
            margin-top: 20px;
            width: 90%;
            max-width: 320px;
            background-color: #161b22;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .mobile-controls .row {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            padding: 0;
            font-size: 1.5em;
            background-color: #58a6ff;
            color: #0d1117;
            box-shadow: 0 3px 0 #3a75c4;
        }

        .mobile-btn.rotate {
            background-color: #f08047; /* Orange for rotation */
            box-shadow: 0 3px 0 #c76f3f;
        }

        /* 미디어 쿼리: 모바일 환경에서 터치 컨트롤 표시 */
        @media (max-width: 700px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .info-panel {
                flex-direction: row;
                width: 90%;
                justify-content: space-around;
            }
            .mobile-controls {
                display: block;
            }
            .controls-panel {
                display: none; /* PC용 버튼 숨김 */
            }
        }
    </style>
</head>
<body>

    <div class="game-container">
        
        <div class="info-panel">
            
            <div class="header-info">
                <h1>TETRIS</h1>
                <div class="developer-info">
                    프로그램 개발자: **21216 전현주**
                </div>
            </div>

            <div class="score-box">
                <p>점수:</p>
                <div id="score">0</div>
            </div>

            <div class="next-box">
                <p>다음 블록:</p>
                <canvas id="next-canvas" width="100" height="100"></canvas>
            </div>
            
        </div>

        <div style="position: relative;">
            <canvas id="game-canvas" width="300" height="600"></canvas>
            
            <div id="message-overlay">
                <h2>게임 오버!</h2>
                <p>점수: <span id="final-score">0</span></p>
                <button onclick="startGame()">다시 시작</button>
            </div>
        </div>
        
    </div>

    <div class="controls-panel">
        <button onclick="startGame()">게임 시작 / 다시 시작</button>
        <button onclick="rotatePiece()">회전 (W/↑)</button>
        <button onclick="movePiece('left')">왼쪽 (A/←)</button>
        <button onclick="movePiece('right')">오른쪽 (D/→)</button>
        <button onclick="softDrop()">아래 (S/↓)</button>
        <button onclick="hardDrop()">하드 드롭 (Space)</button>
    </div>

    <!-- 모바일 터치 컨트롤 -->
    <div class="mobile-controls">
        <div class="row">
            <button class="mobile-btn rotate" onclick="rotatePiece()">↻</button>
        </div>
        <div class="row">
            <button class="mobile-btn" onclick="movePiece('left')">←</button>
            <button class="mobile-btn" onclick="softDrop()">↓</button>
            <button class="mobile-btn" onclick="movePiece('right')">→</button>
        </div>
        <div class="row">
             <button style="width: 90%;" onclick="hardDrop()">하드 드롭</button>
        </div>
    </div>


    <script>
        // =================================================================
        // 1. 게임 설정 및 상수
        // =================================================================

        const COLS = 10; // 열 (Columns)
        const ROWS = 20; // 행 (Rows)
        const BLOCK_SIZE = 30; // 블록 크기 (픽셀)

        // 캔버스 설정
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');
        const NEXT_SIZE = 4;
        nextCanvas.width = NEXT_SIZE * BLOCK_SIZE;
        nextCanvas.height = NEXT_SIZE * BLOCK_SIZE;

        // UI 요소
        const scoreElement = document.getElementById('score');
        const messageOverlay = document.getElementById('message-overlay');
        const finalScoreElement = document.getElementById('final-score');

        // 게임 상태 변수
        let grid; // 게임 보드 상태 배열
        let score = 0;
        let currentPiece;
        let nextPiece;
        let animationFrameId;
        let lastTime = 0;
        let dropCounter = 0;
        const DROP_INTERVAL = 1000; // 블록이 1초마다 떨어짐 (1000ms)

        // 테트로미노 정의 (모양과 색상)
        const TETROMINOES = {
            'I': { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#00ffff' }, // Cyan
            'J': { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#0000ff' }, // Blue
            'L': { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#ff7f00' }, // Orange
            'O': { shape: [[1, 1], [1, 1]], color: '#ffff00' }, // Yellow
            'S': { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#00ff00' }, // Green
            'T': { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#800080' }, // Purple
            'Z': { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#ff0000' }  // Red
        };

        const PIECE_TYPES = Object.keys(TETROMINOES);
        
        // =================================================================
        // 2. 헬퍼 함수
        // =================================================================

        /**
         * 8x8 배열을 생성하고 빈 값(0)으로 채웁니다.
         * @returns {Array<Array<number>>} 초기화된 게임 그리드
         */
        function createGrid() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        /**
         * 무작위로 테트로미노를 생성합니다.
         * @returns {object} 테트로미노 객체 { matrix, color, x, y }
         */
        function getRandomPiece() {
            const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
            const piece = TETROMINOES[type];
            return {
                matrix: piece.shape,
                color: piece.color,
                // x 위치를 가운데로 설정
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0
            };
        }

        /**
         * 행렬을 시계 방향으로 회전시킵니다.
         * @param {Array<Array<number>>} matrix 회전할 행렬
         * @returns {Array<Array<number>>} 회전된 행렬
         */
        function rotateMatrix(matrix) {
            const N = matrix.length - 1;
            const result = matrix.map((row, i) =>
                row.map((val, j) => matrix[N - j][i])
            );
            return result;
        }

        /**
         * 충돌 검사: 현재 위치에서 블록이 유효한지 확인합니다.
         * (보드 경계 또는 이미 고정된 블록과 겹치는지 확인)
         * @param {Array<Array<number>>} matrix 검사할 블록 행렬
         * @param {number} offsetX X 오프셋
         * @param {number} offsetY Y 오프셋
         * @returns {boolean} 충돌 여부 (true = 충돌)
         */
        function checkCollision(matrix, offsetX, offsetY) {
            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix[y].length; x++) {
                    if (matrix[y][x] !== 0) {
                        const newX = x + offsetX;
                        const newY = y + offsetY;

                        // 1. 보드 경계를 벗어나는지 확인
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        
                        // 2. 이미 고정된 블록과 겹치는지 확인 (보드 상단 밖으로 나가는 것은 허용)
                        if (newY >= 0 && grid[newY][newX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }


        // =================================================================
        // 3. 게임 액션 및 렌더링
        // =================================================================

        /**
         * 현재 캔버스에 있는 모든 블록(고정된 블록과 현재 떨어지는 블록)을 그립니다.
         */
        function draw() {
            // 캔버스 지우기
            ctx.fillStyle = '#0d1117'; // 배경색
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. 고정된 블록 그리기
            drawMatrix(grid, 0, 0, true);

            // 2. 현재 떨어지는 블록 그리기
            if (currentPiece) {
                drawMatrix(currentPiece.matrix, currentPiece.x, currentPiece.y, false, currentPiece.color);
            }
        }

        /**
         * 행렬(그리드 또는 블록)을 캔버스에 그립니다.
         * @param {Array<Array<number>>} matrix 그릴 행렬
         * @param {number} offsetX 시작 X 열 인덱스
         * @param {number} offsetY 시작 Y 행 인덱스
         * @param {boolean} isGrid 이것이 메인 그리드인지 여부 (그리드일 경우 색상은 그리드 값에서 가져옴)
         * @param {string} pieceColor 블록일 경우 사용할 색상 (isGrid=false일 때만 사용)
         */
        function drawMatrix(matrix, offsetX, offsetY, isGrid = false, pieceColor = null) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const finalX = (x + offsetX) * BLOCK_SIZE;
                        const finalY = (y + offsetY) * BLOCK_SIZE;

                        let color = isGrid ? value : pieceColor;

                        ctx.fillStyle = color;
                        ctx.fillRect(finalX, finalY, BLOCK_SIZE, BLOCK_SIZE);
                        
                        // 블록 경계선 추가 (입체감 부여)
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(finalX, finalY, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }
        
        /**
         * 다음 블록을 Next 캔버스에 그립니다.
         */
        function drawNextPiece() {
            nextCtx.fillStyle = '#0d1117';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            if (nextPiece) {
                // Next 캔버스에 중앙 정렬
                const pieceWidth = nextPiece.matrix[0].length;
                const pieceHeight = nextPiece.matrix.length;
                const startX = Math.floor((NEXT_SIZE - pieceWidth) / 2);
                const startY = Math.floor((NEXT_SIZE - pieceHeight) / 2);
                
                drawNextMatrix(nextPiece.matrix, startX, startY, nextPiece.color);
            }
        }

        /**
         * Next 캔버스 전용 그리기 함수
         */
        function drawNextMatrix(matrix, offsetX, offsetY, pieceColor) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const finalX = (x + offsetX) * BLOCK_SIZE;
                        const finalY = (y + offsetY) * BLOCK_SIZE;

                        ctx.fillStyle = pieceColor;
                        nextCtx.fillStyle = pieceColor;
                        nextCtx.fillRect(finalX, finalY, BLOCK_SIZE, BLOCK_SIZE);
                        
                        nextCtx.strokeStyle = '#000000';
                        nextCtx.lineWidth = 1;
                        nextCtx.strokeRect(finalX, finalY, BLOCK_SIZE, BLOCK_SIZE);
                    }
                });
            });
        }


        /**
         * 블록 이동 처리 (좌, 우, 아래)
         * @param {string} dir 'left', 'right', 'down'
         */
        function movePiece(dir) {
            if (!currentPiece) return;

            let dx = 0;
            let dy = 0;

            if (dir === 'left') dx = -1;
            else if (dir === 'right') dx = 1;
            else if (dir === 'down') dy = 1;

            if (!checkCollision(currentPiece.matrix, currentPiece.x + dx, currentPiece.y + dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                draw();
            } else if (dir === 'down') {
                // 아래로 이동이 막혔다면, 블록을 고정합니다.
                lockPiece();
            }
        }
        
        /**
         * 소프트 드롭 (Soft Drop): 아래 방향키를 눌러 블록을 한 칸 떨어뜨립니다.
         */
        function softDrop() {
            movePiece('down');
            score += 1; // 소프트 드롭 시 점수 보너스
            updateScore();
        }

        /**
         * 하드 드롭 (Hard Drop): 블록을 즉시 바닥으로 떨어뜨리고 고정합니다.
         */
        function hardDrop() {
            if (!currentPiece) return;
            while (!checkCollision(currentPiece.matrix, currentPiece.x, currentPiece.y + 1)) {
                currentPiece.y++;
                score += 2; // 하드 드롭 시 더 큰 점수 보너스
            }
            lockPiece();
            updateScore();
        }

        /**
         * 블록 회전 처리
         */
        function rotatePiece() {
            if (!currentPiece) return;
            const originalMatrix = currentPiece.matrix;
            currentPiece.matrix = rotateMatrix(originalMatrix);

            // 회전 후 충돌 발생 시, 킥(Kick) 규칙 구현 (간단 버전: 벽 충돌만 처리)
            if (checkCollision(currentPiece.matrix, currentPiece.x, currentPiece.y)) {
                // 오른쪽 벽 충돌 시 왼쪽으로 이동
                if (currentPiece.x + currentPiece.matrix[0].length > COLS) {
                    currentPiece.x -= 1;
                }
                // 왼쪽 벽 충돌 시 오른쪽으로 이동
                else if (currentPiece.x < 0) {
                    currentPiece.x += 1;
                }
                
                // 그럼에도 충돌한다면, 회전을 되돌림
                if (checkCollision(currentPiece.matrix, currentPiece.x, currentPiece.y)) {
                    currentPiece.matrix = originalMatrix;
                }
            }
            draw();
        }

        /**
         * 현재 블록을 그리드에 고정하고 다음 블록을 가져옵니다.
         */
        function lockPiece() {
            currentPiece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        const finalY = currentPiece.y + y;
                        const finalX = currentPiece.x + x;
                        if (finalY < 0) {
                            // 블록이 생성되자마자 고정되면 게임 오버
                            gameOver();
                            return;
                        }
                        grid[finalY][finalX] = currentPiece.color;
                    }
                });
            });

            // 라인 클리어 확인
            clearLines();
            
            // 다음 블록으로 교체
            currentPiece = nextPiece;
            nextPiece = getRandomPiece();
            drawNextPiece();
            
            // 다음 블록이 생성 위치에서 바로 충돌하면 게임 오버
            if (checkCollision(currentPiece.matrix, currentPiece.x, currentPiece.y)) {
                gameOver();
            }
        }

        /**
         * 완성된 라인을 확인하고 제거하며 점수를 업데이트합니다.
         */
        function clearLines() {
            let linesCleared = 0;

            for (let y = ROWS - 1; y >= 0; y--) {
                // 라인이 모두 채워졌는지 확인
                if (grid[y].every(cell => cell !== 0)) {
                    linesCleared++;
                    
                    // 라인 제거 및 그리드 이동
                    const rowToRemove = grid.splice(y, 1)[0]; // 해당 라인 제거
                    grid.unshift(Array(COLS).fill(0)); // 그리드 맨 위에 빈 라인 추가
                    y++; // 현재 위치에서 다시 검사 (위에서 떨어진 새 라인)
                }
            }
            
            if (linesCleared > 0) {
                // 점수 계산 (단순화된 계산)
                score += linesCleared * 100 * linesCleared; // 한번에 여러 줄을 지우면 보너스
                updateScore();
            }
        }

        /**
         * 점수를 UI에 업데이트합니다.
         */
        function updateScore() {
            scoreElement.textContent = score;
        }

        /**
         * 게임 오버 상태를 처리하고 메시지를 표시합니다.
         */
        function gameOver() {
            cancelAnimationFrame(animationFrameId);
            finalScoreElement.textContent = score;
            messageOverlay.classList.add('active');
        }

        // =================================================================
        // 4. 메인 루프 및 초기화
        // =================================================================

        /**
         * 메인 게임 루프 (중력 및 업데이트)
         * @param {number} time 현재 시간 (ms)
         */
        function gameLoop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > DROP_INTERVAL) {
                movePiece('down');
                dropCounter = 0;
            }

            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * 게임을 시작하거나 재시작합니다.
         */
        function startGame() {
            // 기존 루프 중단
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // 게임 상태 초기화
            grid = createGrid();
            score = 0;
            updateScore();
            
            // 첫 블록 생성
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            
            // UI 초기화
            messageOverlay.classList.remove('active');
            drawNextPiece();

            // 게임 루프 시작
            lastTime = 0;
            dropCounter = 0;
            gameLoop();
        }

        // =================================================================
        // 5. 키보드 이벤트 핸들러
        // =================================================================

        document.addEventListener('keydown', event => {
            if (!currentPiece || messageOverlay.classList.contains('active')) return;

            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePiece('left');
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePiece('right');
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    softDrop();
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                    rotatePiece();
                    break;
                case ' ': // Spacebar
                    event.preventDefault(); // 페이지 스크롤 방지
                    hardDrop();
                    break;
            }
        });

        // 페이지 로드 시 게임 시작 버튼 클릭을 대기
        window.onload = () => {
             // 캔버스 크기 조정 (모바일에서 폰트 크기 등으로 인해 높이 보정)
            canvas.style.maxHeight = `${ROWS * BLOCK_SIZE}px`;
            canvas.style.maxWidth = `${COLS * BLOCK_SIZE}px`;
            
            // 초기 게임 오버 메시지 표시 (시작 대기 상태)
            finalScoreElement.textContent = 0;
            messageOverlay.querySelector('h2').textContent = 'TETRIS';
            messageOverlay.querySelector('p').textContent = '시작하려면 버튼을 클릭하세요!';
            messageOverlay.classList.add('active');
        };

    </script>
</body>
</html>
